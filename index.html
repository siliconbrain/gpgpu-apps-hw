<!doctype html>
<html>
    <head>
        <style>
            body {
                display: flex;
            }

            canvas {
                border: 1px solid #bbb;
                width: 800px;
                height: 600px;
            }

            #controls {
                display: flex;
                flex-direction: column;
                margin: 10px;
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ramda/0.23.0/ramda.js" integrity="sha256-+tez7CrvhTdrcPOAdrghnMuXoaDM1SCmOIS6vZ0FuQU=" crossorigin="anonymous"></script>
        <script id="vertex-shader" type="glsl">
            attribute vec3 a_position;
            attribute vec3 a_normal;
            uniform mat4 u_matrix;
            varying vec3 v_normal;

            void main() {
                v_normal = a_normal;
                gl_Position = u_matrix * vec4(a_position.x, a_position.y, a_position.z, 1.0);
            }
        </script>
        <script id="fragment-shader" type="glsl">
            precision mediump float;
            varying vec3 v_normal;

            void main() {
                gl_FragColor = gl_FrontFacing ? vec4(1, 0, 1, 1) : vec4(0, 1, 1, 1);
                float ambientLuminosity = 0.5;
                gl_FragColor.rgb *= max(dot(v_normal, normalize(vec3(1, 1, 1))) * (gl_FrontFacing ? 1.0 : -1.0), 0.0) * (1.0 - ambientLuminosity) + ambientLuminosity;
            }
        </script>
        <script>
            var DEBUG = true;

            function updateCanvasBackBufferSize(gl, scale=1) {
                var canvas = gl.canvas;
                var width = canvas.clientWidth / scale;
                var height = canvas.clientHeight / scale;

                if (canvas.width != width || canvas.height != height) {
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                }
            }

            function createGL(canvas) {
                return canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
            }

            function createShader(gl, type, source) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    return shader;
                } else {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                }
            }

            function createProgram(gl, vertexShader, fragmentShader) {
                var program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    return program;
                } else {
                    console.error(gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                }
            }

            var v4 = {
                dot: function(va, vb) {
                    return R.zipWith(R.multiply, va, vb).reduce(R.add);
                }
            };
            window.v4 = v4;
            var m4 = {
                identity: function() {
                    return [
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    ];
                },
                multiply: function(ma, mb) {
                    var mt = this.transpose(mb);
                    ma_rows = R.range(0, 4).map(i => this.row(ma, i));
                    mt_rows = R.range(0, 4).map(i => this.row(mt, i));
                    return R.unnest(ma_rows.map(mar => mt_rows.map(mtr => v4.dot(mar, mtr))));
                },
                rotateX: function(m, angle) {
                    return this.multiply(m, this.rotationX(angle));
                },
                rotateY: function(m, angle) {
                    return this.multiply(m, this.rotationY(angle));
                },
                rotateZ: function(m, angle) {
                    return this.multiply(m, this.rotationZ(angle));
                },
                rotationX: function(angle) {
                    var c = Math.cos(angle);
                    var s = Math.sin(angle);
                    return [
                        1, 0, 0, 0,
                        0, c, s, 0,
                        0, -s, c, 0,
                        0, 0, 0, 1
                    ];
                },
                rotationY: function(angle) {
                    var c = Math.cos(angle);
                    var s = Math.sin(angle);
                    return [
                        c, 0, -s, 0,
                        0, 1, 0, 0,
                        s, 0, c, 0,
                        0, 0, 0, 1
                    ];
                },
                rotationZ: function(angle) {
                    var c = Math.cos(angle);
                    var s = Math.sin(angle);
                    return [
                        c, s, 0, 0,
                        -s, c, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    ];
                },
                row: function(m, r) {
                    return m.slice(r * 4, (r + 1) * 4);
                },
                scale: function(m, sx, sy, sz) {
                    return this.multiply(m, this.scaling(sx, sy, sz));
                },
                scaling: function(sx, sy, sz) {
                    return [
                        sx, 0, 0, 0,
                        0, sy, 0, 0,
                        0, 0, sz, 0,
                        0, 0, 0, 1
                    ];
                },
                translate: function(m, tx, ty, tz) {
                    return this.multiply(m, this.translation(tx, ty, tz));
                },
                translation: function(tx, ty, tz) {
                    return [
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        tx, ty, tz, 1
                    ];
                },
                transpose: function(m) {
                    return [
                        m[0], m[4], m[8], m[12],
                        m[1], m[5], m[9], m[13],
                        m[2], m[6], m[10], m[14],
                        m[3], m[7], m[11], m[15]
                    ];
                },
                uniformScale: function(m, s) {
                    return this.scale(m, s, s, s);
                }
            };
            window.m4 = m4;

            function getGeometry() {
                return fetch('http://localhost:13370/geometry.json', {
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors',
                }).then(response => response.json());
            }

            function init() {
                var canvas = document.querySelector('canvas');
                var vertexShaderSource = document.getElementById('vertex-shader').innerText;
                var fragmentShaderSource = document.getElementById('fragment-shader').innerText;
                var bgColor = [1, 1, 1, 1];

                var gl = createGL(canvas);
                if (DEBUG) window.gl = gl;

                gl.getExtension('OES_element_index_uint');
                
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS);

                var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                var program = createProgram(gl, vertexShader, fragmentShader);
                gl.useProgram(program);

                var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
                gl.enableVertexAttribArray(positionAttributeLocation);

                var normalAttributeLocation = gl.getAttribLocation(program, "a_normal");
                gl.enableVertexAttribArray(normalAttributeLocation);
                
                getGeometry().then(function (geometry) {
                    if (DEBUG) window.geometry = geometry;

                    if (geometry.normals.length !== geometry.vertices.length) console.error('|ns| != |vs|');
                    if (geometry.vertices.length % 3 !== 0) console.error('|vs| % 3 != 0');

                    var vertexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.vertices), gl.STATIC_DRAW);
                    gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

                    var normalBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.normals), gl.STATIC_DRAW);
                    gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);

                    //var indexBuffer = gl.createBuffer();
                    //gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    //gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int32Array(geometry.indices), gl.STATIC_DRAW);

                    var matrixUniformLocation = gl.getUniformLocation(program, "u_matrix");
                    var baseMatrix = m4.uniformScale(m4.translate(m4.identity(), 0, 0, -5), 0.12);
                    var rotationMatrix = m4.identity();

                    updateCanvasBackBufferSize(gl);
                    gl.clearColor(...bgColor);

                    function draw() {
                        gl.uniformMatrix4fv(matrixUniformLocation, false, m4.scale(m4.multiply(baseMatrix, rotationMatrix), 1, canvas.width/canvas.height, 1));
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        var primitiveType = [...document.querySelectorAll('input[name="primitive-type"]')].find(elem => elem.checked).value;
                        gl.drawArrays(gl[primitiveType], 0, geometry.vertices.length / 3);
                    }
                    draw();
                    
                    canvas.addEventListener('mousemove', function (e) {
                        var speed = Math.PI * -0.001;
                        if (e.buttons === 1) {
                            rotationMatrix = m4.rotateY(m4.rotateX(rotationMatrix, e.movementY * speed), e.movementX * speed);
                            draw();
                        }
                    });
                    document.querySelectorAll('input[name="primitive-type"]').forEach(elem => elem.addEventListener('change', () => {
                        draw();
                    }));
                }, err => console.log(err));
            }
        </script>
    </head>
    <body onload="init()">
        <canvas></canvas>
        <div id="controls">
            <label><input type="radio" name="primitive-type" value="POINTS" checked/> points</label>
            <label><input type="radio" name="primitive-type" value="LINE_STRIP"/> line strip</label>
            <label><input type="radio" name="primitive-type" value="TRIANGLES"/> triangles</label>
        </div>
    </body>
</html>